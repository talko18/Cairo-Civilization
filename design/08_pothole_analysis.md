# Pothole Analysis & Fixes

This document catalogs all architectural flaws found during review and the corrections applied to the design.

## Critical Flaws (Architecture-Breaking)

### P1: Collaborative Map Seed Breaks Fog of War

**Location**: `05_fog_of_war.md` §2.1

**Problem**: The "Collaborative Seed Generation" approach has every player contribute randomness, combine it into a seed, then ALL players run `ProceduralGenerate(combined_seed)` locally. This means **every player knows the full map from turn 1**. There is no fog of war for terrain — only for enemy unit positions.

This is the foundational assumption of the fog of war design and it is broken.

**Fix**: Replace with a **dealer-prover** model. A neutral off-chain prover (or a set of MPC nodes) generates the map from the combined seed, commits the Merkle root on-chain, and distributes **encrypted tile packets** to each player. Players can only decrypt tiles when they provide a valid exploration proof (unit in vision range). No single player ever has access to the full map data.

**Severity**: Critical

---

### P2: CombatProof Circuit Requires Two Players' Private States

**Location**: `02_hidden_information_and_zk.md` §3, Pattern 3

**Problem**: The `CombatProof` circuit lists both `attacker_state` and `defender_state` as private inputs. A ZK proof is generated by a single prover who must know all private inputs. No single party has access to both players' full private states, so this circuit **cannot be generated by anyone**.

**Fix**: Split into two separate proofs — `CombatAttackerProof` (generated by attacker with their private state) and `CombatDefenderProof` (generated by defender with their private state). The on-chain contract collects both proofs' public outputs and computes the deterministic combat result. No single circuit ever touches both players' states.

**Severity**: Critical

---

### P3: Combat Requires 4+ On-Chain Transactions

**Location**: `06_combat_and_interactions.md` §2.3

**Problem**: The combat resolution protocol requires 4 separate on-chain transactions:
1. Attacker submits initiation + proof + random commitment
2. Defender responds with proof + random commitment
3. Both reveal random values (2 more txs)
4. Resolution computed

At StarkNet's block times (~30s–2min per block), a single combat takes 2–8 minutes of blockchain latency. A game with 10 battles per turn becomes unplayable.

**Fix**: Collapse to a **2-transaction protocol** by bundling randomness into the turn submission. Each player pre-commits per-turn randomness at the start of their turn (or as part of the turn proof itself), and combat is resolved inline as part of the turn resolution phase. Random values are derived from the combination of both players' committed turn salts + combat index, eliminating the separate commit-reveal.

**Severity**: Critical

---

### P4: No State Synchronization Between Players

**Location**: `04_game_state_and_commitments.md` §5

**Problem**: Each player maintains an independent `PrivateGameState`. But Player B's actions can affect Player A's state (combat damage, city capture, religious pressure, trade route plunder). The design never describes how Player A's next turn proof accounts for Player B's effects on A's state.

If Player A simply ignores Player B's public actions and continues from their old state, the game diverges. If they must incorporate them, the turn proof circuit needs to verify that external effects were correctly applied — but this constraint is missing.

**Fix**: Add an explicit **"incorporate external events"** phase to the turn processing. Each player's turn proof must:
1. Start from their last committed state
2. Apply all pending external events (from other players' public actions since their last turn)
3. Then apply their own actions
4. Commit the new state

The circuit must verify step 2 against the on-chain event log. An `external_events` public input is added to the state transition proof.

**Severity**: Critical

---

### P5: StarkNet Execution Proofs ≠ Privacy Proofs

**Location**: `01_architecture_overview.md` §3, §4

**Problem**: The architecture doc says "Game logic written in Cairo gets validity proofs for free" and implies StarkNet's native proving handles privacy. This conflates two very different things:

1. **StarkNet L2 validity proofs**: Prove to L1 that L2 execution was correct. All L2 state is still publicly visible on the L2 itself.
2. **Client-side privacy proofs**: Custom proofs generated off-chain to hide player state. These require a separate proving pipeline.

If game state is stored in StarkNet contract storage, every sequencer and full node can read it. The "free" proofs don't help with privacy at all.

**Fix**: Clearly separate the two proof systems in the architecture. StarkNet proofs handle settlement and finality. Client-side Cairo proofs (run off-chain, verified on-chain) handle privacy. The architecture must show the off-chain prover as a distinct component that generates proofs of private state transitions, which the on-chain verifier contract checks.

**Severity**: Critical

---

## High Severity Flaws

### P6: Map Salt Contradiction

**Location**: `05_fog_of_war.md` §2, §3.2, §3.3

**Problem**: Section 2 defines `commit_map()` with a single `salt`. Section 3.2 (TileRevealProof) uses `map_salt` as a private witness input. Section 3.3 then says "this is a problem because any player who knows the salt can reveal the whole map" and proposes per-tile salts instead. But the TileRevealProof circuit still references the single `map_salt`, not per-tile salts. The two approaches are contradictory.

**Fix**: Adopt per-tile salts exclusively. The map Merkle tree has leaves `H(tile_data || tile_salt_i)` where `tile_salt_i = Poseidon(master_seed, tile_index)`. The map commitment is the Merkle root (no map-level salt). Tile reveal proofs provide the per-tile salt, and the circuit verifies the Merkle inclusion with it. Update all circuit descriptions for consistency.

**Severity**: High

---

### P7: Tile Reveal Pattern Leaks Unit Movement

**Location**: `05_fog_of_war.md` §3.1

**Problem**: When a player explores new tiles, they submit tile reveals as public actions. The sequence of which tiles get revealed each turn directly traces the player's unit movement path and direction. An opponent can reconstruct where the player's scout/units are heading.

**Fix**: Batch and delay tile reveals. Instead of revealing tiles on the turn they're explored, players accumulate a set of newly explored tiles and reveal them in shuffled batches at fixed intervals (e.g., every 5 turns). The turn proof still validates the player saw these tiles, but the public reveal is decoupled from the exact turn of exploration. Additionally, tiles explored by different units are merged into one batch, obscuring which unit explored which tile.

**Severity**: High

---

### P8: No State Recovery After Client Crash

**Location**: `04_game_state_and_commitments.md`

**Problem**: The private game state exists only on the player's client. If the browser crashes, disk is wiped, or the player switches devices, the private state is lost. Since only the commitment hash is on-chain, the state **cannot be reconstructed**. The game is permanently bricked for that player.

**Fix**: Add an **encrypted state backup** mechanism:
- After each turn, the client encrypts the full private state with the player's StarkNet account key (or a derived key) and posts the ciphertext to a data availability layer (StarkNet blob, IPFS, or Celestia).
- The DA reference (content hash / URI) is stored on-chain alongside the commitment.
- On recovery, the player fetches the ciphertext, decrypts with their key, and resumes.
- Only the player can decrypt (privacy preserved), but the data persists off-client.

**Severity**: High

---

### P9: Contract-Per-Game Deployment is Expensive

**Location**: `03_starknet_contracts.md` §1, §2

**Problem**: The architecture deploys a full `GameInstance` contract plus 7 engine contracts for every match. On StarkNet, contract deployment costs significant gas (declaring class hashes + deploying instances). For a game platform where many matches may be played, this is wasteful.

**Fix**: Use a **singleton pattern** instead. Deploy each engine contract once. Use the `GameInstance` (or a single `GameWorld` contract) to store per-game state in mappings keyed by `game_id`. Engine contracts are shared across all games, receiving `game_id` as a parameter. Only the lightweight `GameInstance` data structure is created per game (a storage allocation in the factory, not a new contract).

**Severity**: High

---

### P10: Fixed Merkle Tree for Dynamic-Size State

**Location**: `04_game_state_and_commitments.md` §3.1

**Problem**: The Merkle tree has a fixed structure (MILITARY/CIVILIAN/KNOWLEDGE/META branches with fixed sub-branches). But the number of units, cities, explored tiles, etc. changes every turn. A fixed binary Merkle tree doesn't naturally handle variable-length arrays.

For example, if a player has 3 units on turn 5 and 20 units on turn 50, the UNITS subtree changes shape entirely. The path lengths change, making Merkle proof verification inconsistent.

**Fix**: Use a **Sparse Merkle Tree (SMT)** with a fixed depth (e.g., depth 32 for units keyed by `unit_id`). This handles dynamic insertion/deletion cleanly — every possible key has a slot, empty slots have a default hash, and proof length is always constant (= tree depth). The root changes only for modified branches.

**Severity**: High

---

## Medium Severity Flaws

### P11: Visibility Challenges Scale Quadratically

**Location**: `05_fog_of_war.md` §4.3, Approach C

**Problem**: The challenge system lets Player A challenge tiles in their vision range to ask "does Player B have a unit here?" With vision range 2–3, a unit sees ~19–37 tiles. With 10 units, that's ~200–370 potential challenges per player per turn. With 6 opponents, that's ~1,200–2,200 challenges per turn, each requiring a ZK proof response.

**Fix**: Replace per-tile challenges with a **zone-based proximity proof**. Divide the map into fixed zones (e.g., 8×8 hex clusters). Each turn, players prove whether they have ANY units in each zone. Zone membership is cheap to prove (one bit per zone). Only when a zone-level match is found do tile-level challenges occur — dramatically reducing the average case.

**Severity**: Medium

---

### P12: Open Borders Requires Knowing Foreign Territory

**Location**: `06_combat_and_interactions.md` §5.4

**Problem**: The circuit must verify "if a unit moved through Player B's territory, open borders must be active." But territory boundaries depend on Player B's cities and culture expansion — which is partially private. The circuit cannot check territory ownership without knowing the opponent's state.

**Fix**: Territory boundaries are determined by city locations (public) and culture range (derivable from public city data + known civics). Since city locations are public on founding, territory can be computed deterministically from public information. Document this explicitly. The circuit uses the on-chain city registry to compute territory, not the opponent's private state.

**Severity**: Medium

---

### P13: Religious Pressure Requires Foreign City Data

**Location**: `06_combat_and_interactions.md` §6.1

**Problem**: Computing religious pressure requires knowing the religious composition and locations of nearby foreign cities. A player may not have this information if they've never explored the area. The turn proof can't verify a computation over unknown data.

**Fix**: Religious pressure only applies from/to **publicly known cities** (cities within the player's explored area, whose religious state was last observed). The pressure computation uses stale data for cities in fog of war, matching how it works in actual Civ VI (you don't know the current state of cities you can't see). The circuit verifies pressure is computed only from the player's `explored_cities` data in their private state.

**Severity**: Medium

---

### P14: Turn Log Storage Grows Unbounded

**Location**: `03_starknet_contracts.md` §2.2

**Problem**: `turn_log: LegacyMap<(u32, ContractAddress), TurnRecord>` stores a record for every turn of every player, forever. A 300-turn 6-player game = 1,800 storage entries that are never cleaned up.

**Fix**: Don't store turn logs in contract storage. Emit them as events only. Events are stored in the transaction receipt and indexed by off-chain services (Torii, Apibara, etc.) but don't cost ongoing storage rent. Only store the current commitment per player and a `last_turn_hash` that chains turns together (for verifiability without storage).

**Severity**: Medium

---

### P15: Completed Techs as Public Leaks Strategy

**Location**: `07_challenges_and_roadmap.md` §2.3

**Problem**: Making completed techs public on completion reveals major strategic information (e.g., completing "Gunpowder" signals military intent). In Civ VI, opponents don't see your completed techs unless they send a spy.

**Fix**: Keep completed techs private by default. They become public only when: (a) a spy successfully performs "Gain Sources" in the player's city, (b) the tech has a visible effect (a new unit type appears, a new building is seen), or (c) the tech is required for a public action (declaring a specific Casus Belli). This matches the base game's information model more faithfully.

**Severity**: Medium

---

## Summary of All Fixes Applied

| # | Flaw | Severity | Fix Applied In |
|---|------|----------|---------------|
| P1 | Map generation breaks fog of war | Critical | `05_fog_of_war.md` |
| P2 | Impossible two-player CombatProof circuit | Critical | `02_hidden_information_and_zk.md` |
| P3 | 4-transaction combat latency | Critical | `06_combat_and_interactions.md` |
| P4 | No state synchronization between players | Critical | `04_game_state_and_commitments.md` |
| P5 | StarkNet execution proofs ≠ privacy proofs | Critical | `01_architecture_overview.md` |
| P6 | Map salt contradiction | High | `05_fog_of_war.md` |
| P7 | Tile reveal leaks movement | High | `05_fog_of_war.md` |
| P8 | No state recovery on crash | High | `04_game_state_and_commitments.md` |
| P9 | Contract-per-game deployment cost | High | `03_starknet_contracts.md` |
| P10 | Fixed Merkle tree for dynamic state | High | `04_game_state_and_commitments.md` |
| P11 | Visibility challenges scale quadratically | Medium | `05_fog_of_war.md` |
| P12 | Open borders needs foreign territory data | Medium | `06_combat_and_interactions.md` |
| P13 | Religious pressure needs foreign city data | Medium | `06_combat_and_interactions.md` |
| P14 | Turn log storage unbounded | Medium | `03_starknet_contracts.md` |
| P15 | Completed techs leak strategy | Medium | `07_challenges_and_roadmap.md` |
