<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cairo Civ</title>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#1a1a2e;--bg2:#16213e;--panel:#0f3460;--accent:#e94560;--accent2:#c73a52;
--gold:#f5c542;--text:#e0e0e0;--dim:#8899aa;--border:#2a3a5e;
--food:#66bb6a;--prod:#ff9800;--sci:#4fc3f7;--rad:6px;
--p0:#3498db;--p0bg:rgba(52,152,219,.18);--p0txt:#5dade2;
--p1:#e74c3c;--p1bg:rgba(231,76,60,.18);--p1txt:#ec7063}
html,body{height:100%;overflow:hidden}
body{font-family:'Segoe UI',system-ui,sans-serif;background:var(--bg);color:var(--text);display:flex;flex-direction:column}
button{cursor:pointer;font-family:inherit;border:none;border-radius:var(--rad);transition:background .15s}

/* ── Setup overlay ── */
#setup{position:fixed;inset:0;background:var(--bg);z-index:100;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:20px}
#setup h1{font-size:2.4rem;color:var(--gold);letter-spacing:2px}
#setup p{color:var(--dim);max-width:500px;text-align:center;line-height:1.5}
#setup-btn{padding:14px 40px;font-size:1.1rem;font-weight:700;background:var(--accent);color:#fff;border-radius:8px}
#setup-btn:hover{background:var(--accent2)}
#setup-btn:disabled{opacity:.5;cursor:wait}
#setup-log{color:var(--dim);font-size:.82rem;min-height:1.2em}
#setup-error{color:#e74c3c;font-size:.82rem;max-width:600px;word-break:break-all}

/* ── Top bar ── */
#top-bar{display:flex;align-items:center;gap:10px;background:linear-gradient(180deg,#0d1b2a,var(--bg2));
  padding:8px 16px;border-bottom:1px solid var(--border);flex-shrink:0}
.badge{display:flex;align-items:center;gap:4px;background:rgba(255,255,255,.06);
  padding:4px 10px;border-radius:20px;font-size:.82rem;font-weight:600;border:1px solid rgba(255,255,255,.08)}
.badge .dot{width:10px;height:10px;border-radius:50%;flex-shrink:0}
#turn-lbl{font-size:1.1rem;color:var(--gold);font-weight:700;margin-right:8px}
#player-lbl{font-size:.85rem;padding:4px 12px;border-radius:20px;font-weight:700}
.p0{background:var(--p0bg);color:var(--p0txt)}
.p1{background:var(--p1bg);color:var(--p1txt)}
#spacer{flex:1}
#end-btn{padding:6px 18px;background:linear-gradient(135deg,#c0392b,#e74c3c);color:#fff;
  font-size:.85rem;font-weight:700;border-radius:6px;box-shadow:0 2px 8px rgba(231,76,60,.3)}
#end-btn:hover{background:linear-gradient(135deg,#a93226,#c0392b)}
#end-btn:disabled{opacity:.5;cursor:wait}

/* ── Toast notifications ── */
#toast-container{position:fixed;top:60px;right:20px;z-index:9999;display:flex;flex-direction:column;gap:8px;pointer-events:none;max-width:420px}
.toast{pointer-events:auto;padding:12px 18px;border-radius:8px;font-size:.85rem;line-height:1.4;
  box-shadow:0 4px 20px rgba(0,0,0,.5);animation:toast-in .3s ease-out;display:flex;gap:10px;align-items:flex-start}
.toast.toast-error{background:linear-gradient(135deg,#4a1a1a,#6b2020);border:1px solid #e74c3c;color:#f5c6cb}
.toast.toast-error .toast-icon{color:#e74c3c;font-size:1.1rem;flex-shrink:0;margin-top:1px}
.toast.toast-success{background:linear-gradient(135deg,#1a3a1a,#1e4d2b);border:1px solid #27ae60;color:#c3e6cb}
.toast.toast-success .toast-icon{color:#27ae60;font-size:1.1rem;flex-shrink:0;margin-top:1px}
.toast .toast-body{flex:1}
.toast .toast-title{font-weight:700;font-size:.9rem;margin-bottom:3px}
.toast .toast-detail{font-size:.78rem;color:rgba(255,255,255,.65);word-break:break-word}
.toast .toast-close{cursor:pointer;color:rgba(255,255,255,.5);font-size:1rem;flex-shrink:0;margin:-2px -4px 0 0;background:none;padding:2px 6px;border-radius:4px}
.toast .toast-close:hover{color:#fff;background:rgba(255,255,255,.1)}
.toast.toast-out{animation:toast-out .25s ease-in forwards}
@keyframes toast-in{from{opacity:0;transform:translateX(40px)}to{opacity:1;transform:translateX(0)}}
@keyframes toast-out{from{opacity:1;transform:translateX(0)}to{opacity:0;transform:translateX(40px)}}

/* ── Main layout ── */
#main{flex:1;display:flex;overflow:hidden}

/* ── Left sidebar ── */
#sidebar{width:260px;background:var(--bg2);border-right:1px solid var(--border);display:flex;flex-direction:column;flex-shrink:0;overflow:hidden}
#sidebar-tabs{display:flex;border-bottom:1px solid var(--border);flex-shrink:0}
.stab{flex:1;padding:8px 0;text-align:center;font-size:.78rem;font-weight:700;text-transform:uppercase;
  letter-spacing:.5px;background:transparent;color:var(--dim);border-bottom:2px solid transparent;border-radius:0}
.stab.active{color:var(--gold);border-bottom-color:var(--gold);background:rgba(245,197,66,.06)}
.stab:hover{color:var(--text);background:rgba(255,255,255,.04)}
#sidebar-body{flex:1;overflow-y:auto;padding:6px}

/* sidebar cards */
.s-section{margin-bottom:10px}
.s-section-title{font-size:.7rem;text-transform:uppercase;letter-spacing:1px;color:var(--dim);
  padding:4px 8px;margin-bottom:2px}
.s-card{display:flex;align-items:center;gap:8px;padding:8px 10px;border-radius:var(--rad);cursor:pointer;
  border:1px solid transparent;margin-bottom:2px;transition:all .12s}
.s-card:hover{background:rgba(255,255,255,.06);border-color:rgba(255,255,255,.08)}
.s-card.selected{background:rgba(245,197,66,.1);border-color:var(--gold)}
.s-card.dead{opacity:.35;cursor:default}
.s-icon{width:32px;height:32px;border-radius:50%;display:flex;align-items:center;justify-content:center;
  font-size:14px;flex-shrink:0;border:2px solid rgba(255,255,255,.15)}
.s-icon.p0{background:rgba(52,152,219,.25);border-color:rgba(52,152,219,.4)}
.s-icon.p1{background:rgba(231,76,60,.25);border-color:rgba(231,76,60,.4)}
.s-info{flex:1;min-width:0}
.s-name{font-size:.82rem;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.s-detail{font-size:.7rem;color:var(--dim)}
.s-hp{width:40px;text-align:right;flex-shrink:0}
.s-hp-bar{height:4px;border-radius:2px;background:#333;margin-top:2px}
.s-hp-fill{height:100%;border-radius:2px}

/* ── Map ── */
#map-area{flex:1;position:relative;overflow:hidden;background:#0a1628;cursor:grab}
#map-area.dragging{cursor:grabbing}
#map-canvas{position:absolute;top:0;left:0}
#tile-tip{position:absolute;pointer-events:none;background:rgba(10,22,40,.94);border:1px solid var(--border);
  border-radius:var(--rad);padding:8px 12px;font-size:.78rem;z-index:20;display:none;max-width:280px;backdrop-filter:blur(4px);line-height:1.5}
#tile-tip b{color:var(--gold)}
#tile-tip .yield-row{margin-top:3px;font-size:.82rem;letter-spacing:.5px}

/* ── Action mode banner ── */
#mode-banner{position:absolute;top:10px;left:50%;transform:translateX(-50%);background:rgba(233,69,96,.9);
  color:#fff;padding:6px 20px;border-radius:20px;font-size:.82rem;font-weight:600;z-index:15;display:none}

/* ── Bottom action bar ── */
#action-bar{display:flex;align-items:center;gap:6px;background:linear-gradient(0deg,#0d1b2a,var(--bg2));
  border-top:1px solid var(--border);padding:8px 16px;flex-shrink:0;min-height:52px;flex-wrap:wrap}
#action-bar .label{font-size:.78rem;color:var(--dim);margin-right:4px}
#action-bar .sel-name{font-size:.88rem;font-weight:700;color:var(--gold);margin-right:12px}
.ab{display:inline-flex;align-items:center;gap:4px;padding:6px 12px;font-size:.76rem;font-weight:600;
  background:rgba(255,255,255,.07);color:var(--text);border:1px solid rgba(255,255,255,.1);border-radius:var(--rad)}
.ab:hover{background:var(--panel);border-color:var(--accent)}
.ab.pri{background:var(--accent);color:#fff;border-color:var(--accent)}
.ab.pri:hover{background:var(--accent2)}
.ab.cancel{background:rgba(231,76,60,.15);color:#ec7063;border-color:rgba(231,76,60,.3)}
.ab.cancel:hover{background:rgba(231,76,60,.25)}

/* ── Right panel (tech / production) ── */
#rpanel{width:300px;background:var(--bg2);border-left:1px solid var(--border);display:none;flex-direction:column;flex-shrink:0;overflow:hidden;transition:width .2s}
#rpanel.open{display:flex}
#rpanel.wide{width:640px}
#rp-head{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid var(--border)}
#rp-head h2{font-size:.9rem;font-weight:700;text-transform:uppercase;color:var(--gold)}
#rp-close{width:28px;height:28px;display:flex;align-items:center;justify-content:center;
  background:rgba(255,255,255,.08);color:var(--text);font-size:1rem;border-radius:var(--rad)}
#rp-body{flex:1;overflow:auto;padding:10px}
.rp-item{padding:8px 10px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.06);
  border-radius:var(--rad);font-size:.8rem;cursor:pointer;margin-bottom:4px;
  display:flex;justify-content:space-between;align-items:center}
.rp-item:hover{background:var(--panel);border-color:var(--accent)}
.rp-item .meta{font-size:.7rem;color:var(--dim)}

/* ── Tech tree (horizontal left-to-right) ── */
.tech-tree{position:relative;min-width:604px;min-height:420px}
.tech-node{position:absolute;width:94px;height:40px;border-radius:6px;text-align:center;font-size:.7rem;
  border:2px solid rgba(255,255,255,.12);background:rgba(255,255,255,.03);color:var(--dim);cursor:default;
  transition:all .15s;display:flex;flex-direction:column;justify-content:center;z-index:1;box-sizing:border-box}
.tech-node .tn-name{display:block;line-height:1.15;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding:0 3px}
.tech-node .tn-cost{display:block;font-size:.58rem;opacity:.6;margin-top:1px}
/* Era column labels */
.tech-era-label{position:absolute;font-size:.55rem;text-transform:uppercase;letter-spacing:.1em;color:var(--dim);
  writing-mode:vertical-rl;text-orientation:mixed;transform:rotate(180deg);z-index:2;opacity:.5}
/* States */
.tech-node.done{background:rgba(76,175,80,.12);border-color:rgba(76,175,80,.5);color:var(--text)}
.tech-node.done .tn-name{text-decoration:line-through;opacity:.7}
.tech-node.available{background:rgba(255,215,0,.1);border-color:var(--gold);color:#fff;font-weight:700;cursor:pointer}
.tech-node.available:hover{background:rgba(255,215,0,.22);border-color:#ffe066;box-shadow:0 0 8px rgba(255,215,0,.25)}
.tech-node.locked{opacity:.4}
/* SVG connectors */
.tech-tree svg.tree-lines{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0}
.tree-line{stroke:rgba(255,255,255,.18);stroke-width:1.5;fill:none}
.tree-line.done{stroke:rgba(76,175,80,.55);stroke-width:2}

::-webkit-scrollbar{width:5px}::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
</style>
</head>
<body>

<!-- ═══ TOAST CONTAINER ═══ -->
<div id="toast-container"></div>

<!-- ═══ SETUP SCREEN ═══ -->
<div id="setup">
  <h1>CAIRO CIV</h1>
  <p>A fully on-chain Civilization game built with Cairo and StarkNet.<br>
     Make sure <code>katana --dev --dev.no-fee --dev.no-account-validation</code> is running.</p>
  <button id="setup-btn" onclick="doSetup()">Deploy &amp; Start Game</button>
  <div id="setup-log"></div>
  <div id="setup-error"></div>
</div>

<!-- ═══ GAME SCREEN ═══ -->
<div id="top-bar" style="display:none">
  <span id="turn-lbl">Turn 0</span>
  <span id="player-lbl" class="p0">Player A</span>
  <div class="badge"><span class="dot" style="background:var(--gold)"></span><span id="gold-lbl">0</span></div>
  <div class="badge"><span class="dot" style="background:var(--sci)"></span><span id="tech-lbl">--</span></div>
  <div class="badge"><span class="dot" style="background:var(--p1)"></span><span id="diplo-lbl">Peace</span></div>
  <div class="badge" id="queue-badge" style="display:none;background:#554;border:1px solid #aa8"><span id="queue-lbl">0 queued</span></div>
  <div id="spacer"></div>
  <button class="ab" onclick="openPanel('tech')">Research</button>
  <button class="ab" onclick="openPanel('prod')">Production</button>
  <button id="end-btn" onclick="endTurn()">END TURN</button>
</div>

<div id="main" style="display:none">
  <!-- Left sidebar -->
  <div id="sidebar">
    <div id="sidebar-tabs">
      <button class="stab active" data-tab="mine" onclick="switchTab('mine')">My Forces</button>
      <button class="stab" data-tab="enemy" onclick="switchTab('enemy')">Enemy</button>
    </div>
    <div id="sidebar-body"></div>
  </div>

  <!-- Map -->
  <div id="map-area">
    <canvas id="map-canvas"></canvas>
    <div id="tile-tip"></div>
    <div id="mode-banner"></div>
  </div>

  <!-- Right panel (tech/prod picker) -->
  <div id="rpanel">
    <div id="rp-head"><h2 id="rp-title">Panel</h2><button id="rp-close" onclick="closePanel()">&#x2715;</button></div>
    <div id="rp-body"></div>
  </div>
</div>

<!-- Bottom action bar -->
<div id="action-bar" style="display:none">
  <span class="label">No selection</span>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════
let G = null;           // game state from /api/state
let selected = null;    // {type:'unit'|'city', player, id, ...}
let actionMode = null;  // 'move'|'attack'|'ranged'|null
let loading = false;
let sidebarTab = 'mine';

// Map rendering
const COLS=32, ROWS=20, S=26, HW=2*S, HH=Math.sqrt(3)*S;
let camX=0, camY=0;
let hoveredHex = null;

const TERRAIN_COLORS = [
  '#0b3d6e','#1a6fa0','#4a8c3f','#3d7a33','#8a9a3b','#7a8833',
  '#c2a84e','#b89840','#7a9a8a','#6a8a7a','#c8d8e0','#a8b8c0','#6b6b78'
];
const TERRAIN_NAMES = [
  'Ocean','Coast','Grassland','Grassland Hills','Plains','Plains Hills',
  'Desert','Desert Hills','Tundra','Tundra Hills','Snow','Snow Hills','Mountain'
];
// Feature IDs: 0=None, 1=Woods, 2=Rainforest, 3=Marsh, 4=Oasis
const FEATURE_NAMES = ['','Woods','Rainforest','Marsh','Oasis'];
// Resource IDs: 0=None, 1=Wheat, 2=Rice, 3=Cattle, 4=Stone, 5=Fish, 6=Horses, 7=Iron, 8=Silver, 9=Silk, 10=Dyes
const RESOURCE_NAMES = ['','Wheat','Rice','Cattle','Stone','Fish','Horses','Iron','Silver','Silk','Dyes'];
const IMPROVEMENT_NAMES = ['','Farm','Mine','Quarry','Pasture','Lumber Mill'];

// ── Tile yield calculation (mirrors contract logic in city.cairo) ──
function computeTileYield(tile) {
  const t = tile.terrain;
  // Base terrain yields: food
  const FOOD  = [1,1,2,2,1,1,0,0,1,1,0,0,0]; // Ocean..Mountain
  // Base terrain yields: production
  const PROD  = [0,0,0,1,1,2,0,1,0,1,0,1,0];
  // Base terrain yields: gold
  const GOLD  = [0,1,0,0,0,0,0,0,0,0,0,0,0];
  let food = FOOD[t]||0, prod = PROD[t]||0, gold = GOLD[t]||0;

  // Feature bonus
  if(tile.feature === 1) prod += 1; // Woods: +1 prod

  // Resource bonus (matches contract: Wheat=1, Rice=2, Cattle=3 → +1 food;
  // Fish=5 → +1 food; Stone=4, Iron=7 → +1 prod; Horses=6 → +1 prod;
  // Silver=8 → +3 gold; Silk=9, Dyes=10 → +2 gold)
  const res = tile.resource;
  if(res===1||res===2||res===3||res===5) food += 1;
  else if(res===4||res===7) prod += 1;
  else if(res===6) prod += 1;
  else if(res===8) gold += 3;
  else if(res===9||res===10) gold += 2;

  // Improvement bonus
  const imp = tile.improvement || 0;
  if(imp===1) food += 1;       // Farm
  else if(imp===2) prod += 1;  // Mine
  else if(imp===3) prod += 1;  // Quarry
  else if(imp===4) prod += 1;  // Pasture
  else if(imp===5) prod += 1;  // Lumber Mill

  return {food, prod, gold};
}

// City center yield: at least 2 food, 1 production
function computeCityCenterYield(tile) {
  const y = computeTileYield(tile);
  if(y.food < 2) y.food = 2;
  if(y.prod < 1) y.prod = 1;
  return y;
}

// Compute total per-turn yields for a city from its worked tiles + bonuses
function computeCityYields(city) {
  const worked = getWorkedTiles(city);
  let food = 0, prod = 0, gold = 0;
  for (const wt of worked) {
    const tile = getTile(wt.q, wt.r);
    if (!tile) continue;
    const y = wt.isCenter ? computeCityCenterYield(tile) : computeTileYield(tile);
    food += y.food; prod += y.prod; gold += y.gold;
  }
  // Palace bonus (capital)
  if (city.isCapital) { prod += 2; gold += 5; }
  // Building bonuses: Market (bit 4) = +3 gold
  if (city.buildings & (1 << 4)) gold += 3;
  return { food, prod, gold, workedCount: worked.length };
}

// Unit type indices match contract: 0=Settler, 1=Builder, 2=Scout, 3=Warrior, 4=Slinger, 5=Archer
const UNIT_NAMES  = ['Settler','Builder','Scout','Warrior','Slinger','Archer','Spearman','Horseman','Swordsman','Crossbowman','Catapult'];
const UNIT_ICONS  = ['\u{1F3D5}','\u{1F528}','\u{1F50D}','\u2694\uFE0F','\u{1F3AF}','\u{1F3F9}','\u{1F6E1}','\u{1F40E}','\u2694\uFE0F','\u{1F3F9}','\u{1F4A3}'];
// ── Toast notification system ──
function showToast(type, title, detail, durationMs = 6000) {
  const container = document.getElementById('toast-container');
  const el = document.createElement('div');
  el.className = `toast toast-${type}`;
  const icon = type === 'error' ? '\u26A0\uFE0F' : '\u2705';
  el.innerHTML = `<span class="toast-icon">${icon}</span><div class="toast-body"><div class="toast-title">${title}</div>${detail ? `<div class="toast-detail">${detail}</div>` : ''}</div><button class="toast-close" onclick="dismissToast(this.parentElement)">\u00D7</button>`;
  container.appendChild(el);
  if (durationMs > 0) {
    setTimeout(() => dismissToast(el), durationMs);
  }
}
function dismissToast(el) {
  if (!el || el.classList.contains('toast-out')) return;
  el.classList.add('toast-out');
  setTimeout(() => el.remove(), 300);
}
function actionLabel(a) {
  switch (a.type) {
    case 'MoveUnit':         return `Move unit #${a.unitId} to (${a.destQ},${a.destR})`;
    case 'AttackUnit':       return `Attack with unit #${a.unitId}`;
    case 'RangedAttack':     return `Ranged attack with unit #${a.unitId}`;
    case 'FoundCity':        return `Found city "${a.name}"`;
    case 'SetProduction':    return `Set city #${a.cityId} production`;
    case 'SetResearch':      return `Set research to tech #${a.techId}`;
    case 'BuildImprovement': return `Build improvement at (${a.q},${a.r})`;
    case 'RemoveImprovement':return `Remove improvement at (${a.q},${a.r})`;
    case 'FortifyUnit':      return `Fortify unit #${a.unitId}`;
    case 'SkipUnit':         return `Skip unit #${a.unitId}`;
    case 'DeclareWar':       return `Declare war`;
    case 'UpgradeUnit':      return `Upgrade unit #${a.unitId}`;
    case 'AssignCitizen':    return `Assign citizen in city #${a.cityId} to (${a.q},${a.r})`;
    case 'UnassignCitizen':  return `Unassign citizen in city #${a.cityId} from (${a.q},${a.r})`;
    case 'EndTurn':          return `End turn`;
    default:                 return a.type;
  }
}
function batchSummary(actions) {
  return actions.map(a => actionLabel(a)).join(', ');
}

const TECH_NAMES  = {1:'Mining',2:'Pottery',3:'Animal Husb.',4:'Archery',5:'Sailing',6:'Irrigation',7:'Writing',
  8:'Masonry',9:'Bronze Working',10:'The Wheel',11:'Currency',12:'Construction',13:'Horseback',14:'Iron Working',
  15:'Celestial Nav.',16:'Mathematics',17:'Engineering',18:'Machinery'};
const BUILDING_NAMES = {0:'Monument',1:'Granary',2:'Walls',3:'Library',4:'Market',5:'Barracks',6:'Water Mill'};
// Production item IDs match contract: PROD_SETTLER=1, PROD_BUILDER=2, PROD_SCOUT=3,
// PROD_WARRIOR=4, PROD_SLINGER=5, PROD_ARCHER=6, buildings start at 64
const PROD_ITEM_NAMES = {
  0:'None', 1:'Settler', 2:'Builder', 3:'Scout', 4:'Warrior', 5:'Slinger', 6:'Archer',
  64:'Monument', 65:'Granary', 66:'Walls', 67:'Library', 68:'Market', 69:'Barracks', 70:'Water Mill'
};
const PROD_ITEM_COST = {
  1:80, 2:50, 3:30, 4:40, 5:35, 6:60,
  64:60, 65:65, 66:80, 67:90, 68:100, 69:90, 70:80
};
// Tech costs in full science points (contract stores half-points internally)
const TECH_COSTS = {
  1:25, 2:25, 3:25, 4:35, 5:40, 6:40, 7:45, 8:50, 9:50,
  10:50, 11:60, 12:80, 13:80, 14:80, 15:80, 16:100, 17:100, 18:100
};

function getBuildingList(bitmask) {
  const list = [];
  for (let i = 0; i < 7; i++) { if (bitmask & (1 << i)) list.push(BUILDING_NAMES[i]); }
  return list;
}

const canvas = document.getElementById('map-canvas');
const ctx2d = canvas.getContext('2d');

// ═══════════════════════════════════════════════════════════════
// SETUP
// ═══════════════════════════════════════════════════════════════
async function doSetup() {
  const btn = document.getElementById('setup-btn');
  const log = document.getElementById('setup-log');
  const err = document.getElementById('setup-error');
  btn.disabled = true; err.textContent = '';
  log.textContent = 'Connecting to Katana & deploying contract...';
  try {
    const res = await fetch('/api/setup', { method: 'POST' });
    const data = await res.json();
    if (!res.ok) throw new Error(data.error);
    log.textContent = 'Loading game state...';
    await refreshState();
    document.getElementById('setup').style.display = 'none';
    document.getElementById('top-bar').style.display = 'flex';
    document.getElementById('main').style.display = 'flex';
    document.getElementById('action-bar').style.display = 'flex';
    centerCamera();
    resizeCanvas();
  } catch (e) {
    err.textContent = 'Error: ' + e.message;
    btn.disabled = false;
    log.textContent = '';
  }
}

async function refreshState() {
  const res = await fetch('/api/state');
  G = await res.json();
  buildTileIndex();
  updateTopBar();
  renderSidebar();
  updateActionBar();
  drawMap();
}

function updateTopBar() {
  if (!G) return;
  document.getElementById('turn-lbl').textContent = 'Turn ' + G.turn;
  const pl = document.getElementById('player-lbl');
  pl.textContent = G.currentPlayer === 0 ? 'Player A' : 'Player B';
  pl.className = G.currentPlayer === 0 ? 'p0' : 'p1';
  const cp = G.players[G.currentPlayer];
  document.getElementById('gold-lbl').textContent = cp.treasury + ' gold';

  // Science display: per-turn rate + current research progress
  const sciPerTurn = cp.halfSciencePerTurn ? (cp.halfSciencePerTurn / 2) : 0;
  const techId = cp.currentResearch;
  let techText = '';
  if (techId) {
    const techName = TECH_NAMES[techId] || 'Tech '+techId;
    const cost = TECH_COSTS[techId] || 0;
    const accHalf = cp.accumulatedHalfScience || 0;
    const accFull = Math.floor(accHalf / 2);
    if (cost > 0 && sciPerTurn > 0) {
      const remaining = Math.max(0, cost - accFull);
      const turnsLeft = Math.ceil(remaining / sciPerTurn);
      techText = `${techName} ${accFull}/${cost} (~${turnsLeft}T) | ${sciPerTurn}/t`;
    } else if (cost > 0) {
      techText = `${techName} ${accFull}/${cost} | ${sciPerTurn}/t`;
    } else {
      techText = `${techName} | ${sciPerTurn}/t`;
    }
  } else {
    techText = sciPerTurn > 0 ? `None (${sciPerTurn}/t)` : '--';
  }
  document.getElementById('tech-lbl').textContent = techText;

  document.getElementById('diplo-lbl').textContent = G.players[0].diplomacy === 1 ? 'WAR' : 'Peace';
}

// ═══════════════════════════════════════════════════════════════
// LEFT SIDEBAR
// ═══════════════════════════════════════════════════════════════
function switchTab(tab) {
  sidebarTab = tab;
  document.querySelectorAll('.stab').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
  renderSidebar();
}

function renderSidebar() {
  if (!G) return;
  const body = document.getElementById('sidebar-body');
  const cp = G.currentPlayer;
  const p = sidebarTab === 'mine' ? cp : (1 - cp);
  const isMine = sidebarTab === 'mine';
  const pData = G.players[p];
  let html = '';

  // Cities section
  if (pData.cities.length > 0) {
    html += '<div class="s-section"><div class="s-section-title">Cities (' + pData.cities.length + ')</div>';
    for (const c of pData.cities) {
      const isSel = selected && selected.type === 'city' && selected.player === p && selected.id === c.id;
      const prodName = PROD_ITEM_NAMES[c.production] || 'None';
      const prodCost = PROD_ITEM_COST[c.production] || 0;
      const prodPct = prodCost > 0 ? Math.min(100, Math.round(c.prodStockpile / prodCost * 100)) : 0;
      const buildings = getBuildingList(c.buildings);

      // Compute per-turn yields from worked tiles
      const cy = computeCityYields(c);
      const foodConsumption = c.population * 2;  // FOOD_PER_CITIZEN = 2
      const foodSurplus = cy.food - foodConsumption;

      html += `<div class="s-card${isSel ? ' selected' : ''}" onclick="selectFromSidebar('city',${p},${c.id})" style="flex-direction:column;align-items:stretch;gap:4px">
        <div style="display:flex;align-items:center;gap:8px">
          <div class="s-icon p${p}">\u{1F3DB}</div>
          <div class="s-info">
            <div class="s-name">${c.name}${c.isCapital ? ' \u2605' : ''}</div>
            <div class="s-detail">Pop ${c.population} \u2022 (${c.q},${c.r}) \u2022 Working ${cy.workedCount} tiles (center + ${cy.workedCount-1} citizens, ${(c.lockedTiles||[]).length} locked)</div>
          </div>
          <div class="s-hp">
            <div style="font-size:.7rem;text-align:right;color:var(--dim)">${c.hp}/200</div>
            <div class="s-hp-bar"><div class="s-hp-fill" style="width:${c.hp/2}%;background:${c.hp>100?'var(--food)':c.hp>50?'var(--prod)':'var(--p1)'}"></div></div>
          </div>
        </div>
        <div style="display:flex;gap:8px;font-size:.72rem;padding:2px 4px;background:rgba(255,255,255,.04);border-radius:4px;margin:2px 0">
          <span title="Food/turn (${cy.food} raw - ${foodConsumption} eaten)" style="color:var(--food)">\u{1F33E} ${foodSurplus >= 0 ? '+' : ''}${foodSurplus}</span>
          <span title="Production/turn" style="color:#f5a623">\u2692 ${cy.prod}</span>
          <span title="Gold/turn" style="color:var(--gold)">\u{1F4B0} ${cy.gold}</span>
          <span style="color:var(--dim);margin-left:auto" title="Food stockpile">\u{1F4E6} ${c.foodStockpile}</span>
        </div>
        <div style="font-size:.68rem;padding:0 4px;color:var(--dim)">
          Producing: <b style="color:var(--prod)">${prodName}</b>${prodCost>0?' ('+prodPct+'%)':''}
        </div>
        <div style="padding:0 4px">
          <div class="s-hp-bar" style="height:3px"><div class="s-hp-fill" style="width:${prodPct}%;background:var(--prod)"></div></div>
        </div>
        ${buildings.length>0?'<div style="font-size:.65rem;padding:0 4px;color:var(--dim)">Buildings: '+buildings.join(', ')+'</div>':''}
      </div>`;
    }
    html += '</div>';
  }

  // Units section
  const alive = pData.units.filter(u => u.hp > 0);
  const dead = pData.units.filter(u => u.hp <= 0);
  if (alive.length > 0 || dead.length > 0) {
    html += '<div class="s-section"><div class="s-section-title">Units (' + alive.length + ' alive)</div>';
    for (const u of alive) {
      const isSel = selected && selected.type === 'unit' && selected.player === p && selected.id === u.id;
      const uname = UNIT_NAMES[u.unitType] || 'Unit';
      html += `<div class="s-card${isSel ? ' selected' : ''}" onclick="selectFromSidebar('unit',${p},${u.id})">
        <div class="s-icon p${p}">${UNIT_ICONS[u.unitType] || '?'}</div>
        <div class="s-info">
          <div class="s-name">${uname}</div>
          <div class="s-detail">MP:${u.mp}${u.charges ? ' Ch:'+u.charges : ''} \u2022 (${u.q},${u.r})</div>
        </div>
        <div class="s-hp">
          <div style="font-size:.7rem;text-align:right;color:var(--dim)">${u.hp}/100</div>
          <div class="s-hp-bar"><div class="s-hp-fill" style="width:${u.hp}%;background:${u.hp>50?'var(--food)':u.hp>25?'var(--prod)':'var(--p1)'}"></div></div>
        </div>
      </div>`;
    }
    for (const u of dead) {
      const uname = UNIT_NAMES[u.unitType] || 'Unit';
      html += `<div class="s-card dead">
        <div class="s-icon p${p}">${UNIT_ICONS[u.unitType] || '?'}</div>
        <div class="s-info"><div class="s-name">${uname}</div><div class="s-detail">Dead</div></div>
      </div>`;
    }
    html += '</div>';
  }

  // Treasury & research
  const sciPT = pData.halfSciencePerTurn ? (pData.halfSciencePerTurn / 2) : 0;
  const rTechId = pData.currentResearch;
  let researchLine = '';
  if (rTechId) {
    const rName = TECH_NAMES[rTechId] || 'Tech '+rTechId;
    const rCost = TECH_COSTS[rTechId] || 0;
    const rAcc = Math.floor((pData.accumulatedHalfScience || 0) / 2);
    const rPct = rCost > 0 ? Math.min(100, Math.round(rAcc / rCost * 100)) : 0;
    const rTurns = (rCost > 0 && sciPT > 0) ? Math.ceil(Math.max(0, rCost - rAcc) / sciPT) : '?';
    researchLine = `<b style="color:var(--sci)">${rName}</b> (${rAcc}/${rCost}, ~${rTurns}T)`
      + `<div style="margin:3px 0;height:6px;background:rgba(255,255,255,.1);border-radius:3px;overflow:hidden">`
      + `<div style="height:100%;width:${rPct}%;background:var(--sci);border-radius:3px"></div></div>`;
  } else {
    researchLine = '<b style="color:var(--dim)">None</b>';
  }
  html += '<div class="s-section"><div class="s-section-title">Economy</div>';
  html += `<div style="padding:4px 10px;font-size:.78rem;color:var(--dim)">
    \u{1F4B0} Treasury: <b style="color:var(--gold)">${pData.treasury}</b><br>
    \u{1F52C} Science: <b style="color:var(--sci)">${sciPT}</b>/turn<br>
    \u{1F4D6} Research: ${researchLine}
    \u{1F3F3} Diplomacy: <b style="color:${pData.diplomacy===1?'var(--p1)':'var(--food)'}">${pData.diplomacy===1?'At War':'Peace'}</b>
  </div></div>`;

  if (html === '') html = '<div style="padding:20px;color:var(--dim);text-align:center;font-size:.82rem">No data yet</div>';
  body.innerHTML = html;
}

function selectFromSidebar(type, player, id) {
  if (!G) return;
  actionMode = null;
  setModeBanner(null);

  if (type === 'unit') {
    const u = G.players[player].units.find(x => x.id === id);
    if (!u || u.hp <= 0) return;
    selected = { ...u, type: 'unit', player };
    panToHex(u.q, u.r);
  } else {
    const c = G.players[player].cities.find(x => x.id === id);
    if (!c) return;
    selected = { ...c, type: 'city', player };
    panToHex(c.q, c.r);
  }
  updateActionBar();
  renderSidebar();
  drawMap();
}

function panToHex(q, r) {
  const [hx, hy] = hexCenter(q, r);
  camX = -hx + canvas.width / 2;
  camY = -hy + canvas.height / 2;
}

// ═══════════════════════════════════════════════════════════════
// BOTTOM ACTION BAR
// ═══════════════════════════════════════════════════════════════
function updateActionBar() {
  const bar = document.getElementById('action-bar');
  if (!selected) {
    bar.innerHTML = '<span class="label">Click a unit or city on the map, or select from the sidebar.</span>';
    return;
  }

  const isMine = selected.player === G.currentPlayer;

  if (selected.type === 'unit') {
    const u = selected;
    const name = UNIT_NAMES[u.unitType] || 'Unit';
    const icon = UNIT_ICONS[u.unitType] || '?';
    const isCivilian = u.unitType === 0 || u.unitType === 1; // 0=Settler, 1=Builder
    let html = `<span class="sel-name">${icon} ${name}</span>
      <span class="label">HP:${u.hp} MP:${u.mp}${u.charges ? ' Ch:'+u.charges : ''} (${u.q},${u.r})</span>`;

    if (isMine) {
      if (actionMode) {
        const modeName = actionMode === 'move' ? 'Move' : actionMode === 'attack' ? 'Attack' : 'Ranged Attack';
        html += `<button class="ab cancel" onclick="cancelMode()">Cancel ${modeName}</button>`;
      } else {
        html += `<button class="ab pri" onclick="startMove()">Move</button>`;
        if (u.unitType === 0) html += `<button class="ab pri" onclick="foundCity()">Found City</button>`;
        if (!isCivilian) {
          html += `<button class="ab" onclick="startAttack()">Attack</button>`;
          html += `<button class="ab" onclick="fortifyUnit()">Fortify</button>`;
          if (u.unitType === 4 || u.unitType === 5) html += `<button class="ab" onclick="startRanged()">Ranged</button>`; // 4=Slinger, 5=Archer
        }
        html += `<button class="ab" onclick="skipUnit()">Skip</button>`;
        html += `<button class="ab" onclick="declareWar()">Declare War</button>`;
      }
    } else {
      html += '<span class="label" style="margin-left:8px">Enemy unit</span>';
    }

    bar.innerHTML = html;
  } else if (selected.type === 'city') {
    const c = selected;
    const prodName = PROD_ITEM_NAMES[c.production] || 'None';
    const prodCost = PROD_ITEM_COST[c.production] || 0;
    const prodPct = prodCost > 0 ? Math.min(100, Math.round(c.prodStockpile / prodCost * 100)) : 0;
    const turnsLeft = prodCost > 0 && c.population > 0
      ? Math.max(1, Math.ceil((prodCost - c.prodStockpile) / Math.max(1, c.population)))
      : '\u221E';
    const buildings = getBuildingList(c.buildings);
    let html = `<span class="sel-name">\u{1F3DB} ${c.name}${c.isCapital?' \u2605':''}</span>`;
    html += `<span class="label">Pop:${c.population} HP:${c.hp} (${c.q},${c.r})</span>`;
    html += `<span class="badge" style="margin-left:4px"><span class="dot" style="background:var(--food)"></span>\u{1F33E} ${c.foodStockpile}</span>`;
    html += `<span class="badge"><span class="dot" style="background:var(--prod)"></span>\u2692 ${c.prodStockpile}/${prodCost} ${prodName} (~${turnsLeft}T)</span>`;
    if (buildings.length > 0) {
      html += `<span class="badge"><span class="dot" style="background:var(--sci)"></span>${buildings.join(', ')}</span>`;
    }
    if (isMine) {
      html += `<button class="ab pri" onclick="openPanel('prod')">Set Production</button>`;
      html += `<button class="ab" onclick="openPanel('tech')">Set Research</button>`;
    } else {
      html += '<span class="label" style="margin-left:8px">Enemy city</span>';
    }
    bar.innerHTML = html;
  }
}

// ═══════════════════════════════════════════════════════════════
// HEX GEOMETRY
// ═══════════════════════════════════════════════════════════════
function hexCenter(q, r) {
  const x = q * 1.5 * S + S;
  const y = r * HH + HH / 2 + (q % 2 === 1 ? HH / 2 : 0);
  return [x, y];
}
function hexPts(cx, cy, s) {
  const p = [];
  for (let i = 0; i < 6; i++) { const a = i * Math.PI / 3; p.push([cx + s * Math.cos(a), cy + s * Math.sin(a)]); }
  return p;
}
function pixelToHex(px, py) {
  let best=null, bd=Infinity;
  for (let q=0;q<COLS;q++) for (let r=0;r<ROWS;r++) {
    const [hx,hy]=hexCenter(q,r); const d=(px-hx)**2+(py-hy)**2;
    if(d<bd){bd=d;best={q,r};}
  }
  return bd < HH*HH ? best : null;
}
function centerCamera() {
  if (!G) return;
  const cp = G.currentPlayer;
  const u = G.players[cp].units.find(u => u.hp > 0);
  if (u) panToHex(u.q, u.r);
}
function hexDist(q1,r1,q2,r2) {
  // offset hex distance
  function toAxial(q,r) {
    const aq = q;
    const ar = r - Math.floor(q / 2);
    return [aq, ar];
  }
  const [aq1,ar1] = toAxial(q1,r1);
  const [aq2,ar2] = toAxial(q2,r2);
  const dq = aq2-aq1, dr = ar2-ar1;
  return Math.max(Math.abs(dq), Math.abs(dr), Math.abs(dq+dr));
}

// ═══════════════════════════════════════════════════════════════
// MAP DRAWING
// ═══════════════════════════════════════════════════════════════
function resizeCanvas() {
  const area = document.getElementById('map-area');
  canvas.width = area.clientWidth;
  canvas.height = area.clientHeight;
  drawMap();
}
window.addEventListener('resize', resizeCanvas);

let tileIdx = {}; // q,r → tile lookup
function buildTileIndex() {
  tileIdx = {};
  if (!G) return;
  for (const t of G.tiles) tileIdx[t.q + ',' + t.r] = t;
}
function getTile(q,r) {
  return tileIdx[q + ',' + r] || null;
}

// Offset-coordinate hex neighbors for flat-top grid with odd columns shifted down.
// Indexed by visual edge (0-5): edge i connects vertex i to vertex (i+1)%6.
// Each entry is the [dq, dr] offset of the neighbor across that edge.
// Even columns (q%2===0):
const EDGE_NEIGHBOR_EVEN = [
  [+1, -1], // edge 0 (v0→v1): upper-right
  [ 0, -1], // edge 1 (v1→v2): top
  [-1, -1], // edge 2 (v2→v3): upper-left
  [-1,  0], // edge 3 (v3→v4): lower-left
  [ 0, +1], // edge 4 (v4→v5): bottom
  [+1,  0], // edge 5 (v5→v0): lower-right
];
// Odd columns (q%2===1):
const EDGE_NEIGHBOR_ODD = [
  [+1,  0], // edge 0 (v0→v1): upper-right
  [ 0, -1], // edge 1 (v1→v2): top
  [-1,  0], // edge 2 (v2→v3): upper-left
  [-1, +1], // edge 3 (v3→v4): lower-left
  [ 0, +1], // edge 4 (v4→v5): bottom
  [+1, +1], // edge 5 (v5→v0): lower-right
];
function edgeNeighbor(q, r, edge) {
  const off = (q % 2 === 0) ? EDGE_NEIGHBOR_EVEN[edge] : EDGE_NEIGHBOR_ODD[edge];
  return [q + off[0], r + off[1]];
}
// Get all 6 neighbors of a hex (unordered, for general use)
function allNeighbors(q, r) {
  const table = (q % 2 === 0) ? EDGE_NEIGHBOR_EVEN : EDGE_NEIGHBOR_ODD;
  return table.map(off => [q + off[0], r + off[1]]);
}

// Get all territory tiles for a city (hexes_in_range)
function getTerritoryTiles(city) {
  const rad = city.population >= 6 ? 3 : city.population >= 3 ? 2 : 1;
  const tiles = [];
  for (let dx = -rad; dx <= rad; dx++) {
    const loA = -rad, loB = -rad - dx;
    const lo = loA > loB ? loA : loB;
    const hiA = rad, hiB = rad - dx;
    const hi = hiA < hiB ? hiA : hiB;
    for (let dr = lo; dr <= hi; dr++) {
      const sq = city.q + dx, sr = city.r + dr;
      if (sq >= 0 && sq < COLS && sr >= 0 && sr < ROWS) tiles.push({q: sq, r: sr});
    }
  }
  return tiles;
}

// Compute which tiles a city is working.
// City center is ALWAYS worked (free). Each citizen works one additional tile.
// Returns array of {q, r, locked: bool, isCenter: bool}
function getWorkedTiles(city) {
  const pop = city.population;
  const locked = city.lockedTiles || [];
  const result = [];
  const usedSet = new Set();

  // 0. City center is always worked (free, not using a pop slot)
  result.push({q: city.q, r: city.r, locked: false, isCenter: true});
  usedSet.add(city.q + ',' + city.r);

  // Additional tiles = population count
  let additional = 0;

  // 1. Add locked tiles (verify still in territory, skip center)
  for (const lt of locked) {
    if (additional >= pop) break;
    if (lt.q === city.q && lt.r === city.r) continue; // center already added
    const t = getTile(lt.q, lt.r);
    if (!t) continue;
    if (t.ownerCity > 0 && t.ownerCity === city.id + 1 && t.terrain !== 0 && t.terrain !== 12) {
      result.push({q: lt.q, r: lt.r, locked: true, isCenter: false});
      usedSet.add(lt.q + ',' + lt.r);
      additional++;
    }
  }

  if (additional >= pop) return result;

  // 2. Gather remaining territory tiles with scores (exclude center and locked)
  const territory = getTerritoryTiles(city);
  const scored = [];
  for (const tt of territory) {
    if (usedSet.has(tt.q + ',' + tt.r)) continue;
    const tile = getTile(tt.q, tt.r);
    if (!tile || tile.terrain === 0 || tile.terrain === 12) continue;
    const y = computeTileYield(tile);
    const score = y.food * 3 + y.prod * 2 + y.gold;
    scored.push({q: tt.q, r: tt.r, score});
  }

  // 3. Sort by score descending, pick remaining slots
  scored.sort((a, b) => b.score - a.score);
  const remaining = pop - additional;
  for (let i = 0; i < remaining && i < scored.length; i++) {
    result.push({q: scored[i].q, r: scored[i].r, locked: false, isCenter: false});
  }

  return result;
}

const PLAYER_TERRITORY_COLORS = [
  'rgba(52,152,219,.15)',   // P0 blue overlay
  'rgba(231,76,60,.15)',    // P1 red overlay
];
const PLAYER_BORDER_COLORS = [
  'rgba(52,152,219,.7)',    // P0 blue border
  'rgba(231,76,60,.7)',     // P1 red border
];

function drawMap() {
  if (!G) return;
  ctx2d.clearRect(0,0,canvas.width,canvas.height);
  ctx2d.save();
  ctx2d.translate(camX, camY);
  const sz = S;

  // Terrain
  for (const t of G.tiles) {
    const [cx,cy] = hexCenter(t.q, t.r);
    const pts = hexPts(cx,cy,sz);
    ctx2d.beginPath(); ctx2d.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<6;i++) ctx2d.lineTo(pts[i][0],pts[i][1]);
    ctx2d.closePath();
    ctx2d.fillStyle = TERRAIN_COLORS[t.terrain] || '#333';
    ctx2d.fill();
    ctx2d.strokeStyle='rgba(0,0,0,.25)'; ctx2d.lineWidth=1;
    ctx2d.stroke();

    // Draw river edges as thick blue lines on specific hex edges
    if (t.riverEdges) {
      ctx2d.strokeStyle='#3a9fd8'; ctx2d.lineWidth=3; ctx2d.lineCap='round';
      for (let edge=0; edge<6; edge++) {
        if (t.riverEdges & (1 << edge)) {
          ctx2d.beginPath();
          ctx2d.moveTo(pts[edge][0], pts[edge][1]);
          ctx2d.lineTo(pts[(edge+1)%6][0], pts[(edge+1)%6][1]);
          ctx2d.stroke();
        }
      }
      ctx2d.lineCap='butt';
    }

    if (t.feature===1) { ctx2d.font='12px sans-serif'; ctx2d.textAlign='center'; ctx2d.fillText('\u{1F332}',cx-6,cy-4); }
    if (t.feature===2) { ctx2d.font='12px sans-serif'; ctx2d.textAlign='center'; ctx2d.fillText('\u{1F33F}',cx-6,cy-4); }
    if (t.resource) { ctx2d.font='11px sans-serif'; ctx2d.textAlign='center'; ctx2d.fillText([,'\u{1F33E}','\u{1F404}','\u{1FAA8}','\u26CF\uFE0F','\u{1F48E}','\u{1F40E}','\u{1F3A8}'][t.resource]||'',cx+10,cy-6); }
    if (t.terrain===12) { ctx2d.font='16px sans-serif'; ctx2d.textAlign='center'; ctx2d.fillText('\u26F0\uFE0F',cx,cy+5); }
  }

  // Territory overlays — color owned tiles
  for (const t of G.tiles) {
    if (t.ownerCity > 0) {
      const p = t.ownerPlayer;
      const [cx,cy] = hexCenter(t.q, t.r);
      const pts = hexPts(cx,cy,sz);
      ctx2d.beginPath(); ctx2d.moveTo(pts[0][0],pts[0][1]);
      for(let i=1;i<6;i++) ctx2d.lineTo(pts[i][0],pts[i][1]);
      ctx2d.closePath();
      ctx2d.fillStyle = PLAYER_TERRITORY_COLORS[p] || 'rgba(255,255,255,.08)';
      ctx2d.fill();
    }
  }
  // Territory borders — thick colored lines on edges between owned and unowned/different-owner tiles
  ctx2d.lineWidth = 2.5; ctx2d.lineCap = 'round';
  for (const t of G.tiles) {
    if (t.ownerCity <= 0) continue;
    const p = t.ownerPlayer;
    const [cx,cy] = hexCenter(t.q, t.r);
    const pts = hexPts(cx,cy,sz);
    ctx2d.strokeStyle = PLAYER_BORDER_COLORS[p] || 'rgba(255,255,255,.4)';
    for (let edge = 0; edge < 6; edge++) {
      const [nq, nr] = edgeNeighbor(t.q, t.r, edge);
      let drawBorder = false;
      if (nq < 0 || nq >= COLS || nr < 0 || nr >= ROWS) {
        drawBorder = true; // map edge
      } else {
        const nt = getTile(nq, nr);
        if (!nt || nt.ownerCity <= 0 || nt.ownerPlayer !== p) drawBorder = true;
      }
      if (drawBorder) {
        ctx2d.beginPath();
        ctx2d.moveTo(pts[edge][0], pts[edge][1]);
        ctx2d.lineTo(pts[(edge+1)%6][0], pts[(edge+1)%6][1]);
        ctx2d.stroke();
      }
    }
  }
  ctx2d.lineCap = 'butt';

  // Worked tile highlights + yield labels (when a city is selected)
  if (selected && selected.type === 'city') {
    const city = G.players[selected.player].cities.find(c => c.id === selected.id);
    if (city) {
      const worked = getWorkedTiles(city);
      const workedSet = new Set(worked.map(w => w.q+','+w.r));
      const allTerritory = getTerritoryTiles(city);

      // Draw unworked territory tiles with a dim overlay
      for (const at of allTerritory) {
        if (workedSet.has(at.q+','+at.r)) continue;
        const tile = getTile(at.q, at.r);
        if (!tile || tile.terrain === 0 || tile.terrain === 12) continue;
        const [cx,cy] = hexCenter(at.q, at.r);
        const pts = hexPts(cx,cy,sz-1);
        ctx2d.beginPath(); ctx2d.moveTo(pts[0][0],pts[0][1]);
        for(let i=1;i<6;i++) ctx2d.lineTo(pts[i][0],pts[i][1]);
        ctx2d.closePath();
        ctx2d.fillStyle = 'rgba(80,80,80,.25)';
        ctx2d.fill();
        ctx2d.strokeStyle = 'rgba(150,150,150,.3)';
        ctx2d.lineWidth = 1;
        ctx2d.setLineDash([3,3]);
        ctx2d.stroke();
        ctx2d.setLineDash([]);
      }

      // Draw worked tiles: locked = blue highlight, auto = green highlight
      for (const wt of worked) {
        const [cx,cy] = hexCenter(wt.q, wt.r);
        const pts = hexPts(cx,cy,sz-1);
        ctx2d.beginPath(); ctx2d.moveTo(pts[0][0],pts[0][1]);
        for(let i=1;i<6;i++) ctx2d.lineTo(pts[i][0],pts[i][1]);
        ctx2d.closePath();
        if (wt.locked) {
          ctx2d.fillStyle = 'rgba(52,152,219,.25)';  // blue for locked
          ctx2d.fill();
          ctx2d.strokeStyle = 'rgba(52,152,219,.8)';
          ctx2d.lineWidth = 2.5;
        } else {
          ctx2d.fillStyle = 'rgba(102,187,106,.25)';  // green for auto
          ctx2d.fill();
          ctx2d.strokeStyle = 'rgba(102,187,106,.7)';
          ctx2d.lineWidth = 2;
        }
        ctx2d.stroke();

        // Lock icon on locked tiles
        if (wt.locked) {
          ctx2d.font = '10px sans-serif';
          ctx2d.textAlign = 'center';
          ctx2d.textBaseline = 'middle';
          ctx2d.fillStyle = 'rgba(52,152,219,.9)';
          ctx2d.fillText('\u{1F512}', cx + sz*0.3, cy - sz*0.3);
        }

        // Draw yield numbers on tile
        const tile = getTile(wt.q, wt.r);
        if (tile) {
          const y = wt.isCenter ? computeCityCenterYield(tile) : computeTileYield(tile);
          const yParts = [];
          if (y.food) yParts.push({val: y.food, color: '#66bb6a', icon: 'F'});
          if (y.prod) yParts.push({val: y.prod, color: '#f5a623', icon: 'P'});
          if (y.gold) yParts.push({val: y.gold, color: '#ffd54f', icon: 'G'});
          if (yParts.length > 0) {
            const totalW = yParts.length * 20;
            let ox = cx - totalW / 2 + 10;
            const oy = cy + 10;
            ctx2d.fillStyle = 'rgba(0,0,0,.65)';
            const pillX = cx - totalW/2 - 2, pillY = oy - 9;
            ctx2d.beginPath();
            ctx2d.roundRect(pillX, pillY, totalW + 4, 16, 4);
            ctx2d.fill();
            ctx2d.font = 'bold 10px monospace';
            ctx2d.textAlign = 'center';
            ctx2d.textBaseline = 'middle';
            for (const yp of yParts) {
              ctx2d.fillStyle = yp.color;
              ctx2d.fillText(yp.val + yp.icon, ox, oy);
              ox += 20;
            }
          }
        }
      }
    }
  }

  // Selected hex highlight
  if (selected) {
    const [cx,cy] = hexCenter(selected.q, selected.r);
    const pts = hexPts(cx,cy,sz+2);
    ctx2d.beginPath(); ctx2d.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<6;i++) ctx2d.lineTo(pts[i][0],pts[i][1]);
    ctx2d.closePath(); ctx2d.strokeStyle='#f5c542'; ctx2d.lineWidth=3; ctx2d.stroke();
  }

  // Movement range highlight
  if (selected && selected.type==='unit' && actionMode==='move') {
    const range = selected.mp || 1;
    for (let dq=-range*2;dq<=range*2;dq++) for (let dr=-range*2;dr<=range*2;dr++) {
      const nq=selected.q+dq, nr=selected.r+dr;
      if(nq<0||nq>=COLS||nr<0||nr>=ROWS) continue;
      if(dq===0&&dr===0) continue;
      const tile = getTile(nq,nr);
      if(!tile || tile.terrain===0||tile.terrain===1||tile.terrain===12) continue;
      const dist = hexDist(selected.q,selected.r,nq,nr);
      if(dist>range) continue;
      const [hx,hy]=hexCenter(nq,nr);
      const hp=hexPts(hx,hy,sz);
      ctx2d.beginPath(); ctx2d.moveTo(hp[0][0],hp[0][1]);
      for(let i=1;i<6;i++) ctx2d.lineTo(hp[i][0],hp[i][1]);
      ctx2d.closePath(); ctx2d.fillStyle='rgba(245,197,66,.12)'; ctx2d.fill();
      ctx2d.strokeStyle='rgba(245,197,66,.35)'; ctx2d.lineWidth=1.5; ctx2d.stroke();
    }
  }

  // Attack range highlight
  if (selected && selected.type==='unit' && (actionMode==='attack'||actionMode==='ranged')) {
    const range = actionMode==='ranged' ? 2 : 1;
    for (let dq=-range*2;dq<=range*2;dq++) for (let dr=-range*2;dr<=range*2;dr++) {
      const nq=selected.q+dq, nr=selected.r+dr;
      if(nq<0||nq>=COLS||nr<0||nr>=ROWS) continue;
      if(dq===0&&dr===0) continue;
      const dist = hexDist(selected.q,selected.r,nq,nr);
      if(dist>range) continue;
      // Check if enemy unit here
      const enemy = 1 - G.currentPlayer;
      const hasEnemy = G.players[enemy].units.some(u => u.hp>0 && u.q===nq && u.r===nr);
      if (!hasEnemy) continue;
      const [hx,hy]=hexCenter(nq,nr);
      const hp=hexPts(hx,hy,sz);
      ctx2d.beginPath(); ctx2d.moveTo(hp[0][0],hp[0][1]);
      for(let i=1;i<6;i++) ctx2d.lineTo(hp[i][0],hp[i][1]);
      ctx2d.closePath(); ctx2d.fillStyle='rgba(231,76,60,.15)'; ctx2d.fill();
      ctx2d.strokeStyle='rgba(231,76,60,.5)'; ctx2d.lineWidth=2; ctx2d.stroke();
    }
  }

  // Hover highlight
  if (hoveredHex) {
    const [cx,cy] = hexCenter(hoveredHex.q, hoveredHex.r);
    const pts = hexPts(cx,cy,sz+1);
    ctx2d.beginPath(); ctx2d.moveTo(pts[0][0],pts[0][1]);
    for(let i=1;i<6;i++) ctx2d.lineTo(pts[i][0],pts[i][1]);
    ctx2d.closePath(); ctx2d.strokeStyle='rgba(255,255,255,.3)'; ctx2d.lineWidth=2; ctx2d.stroke();
  }

  // Cities
  for (let p=0;p<2;p++) {
    for (const c of G.players[p].cities) {
      const [cx,cy]=hexCenter(c.q,c.r);
      ctx2d.beginPath(); ctx2d.arc(cx,cy,14,0,Math.PI*2);
      ctx2d.fillStyle=p===0?'#2874a6':'#c0392b'; ctx2d.fill();
      ctx2d.strokeStyle='#fff'; ctx2d.lineWidth=2; ctx2d.stroke();
      ctx2d.font='bold 9px sans-serif'; ctx2d.textAlign='center'; ctx2d.fillStyle='#fff';
      ctx2d.fillText(c.name,cx,cy-18);
      ctx2d.font='8px sans-serif'; ctx2d.fillText('Pop '+c.population,cx,cy+4);
      // Production bar under city circle
      const prodCost = PROD_ITEM_COST[c.production] || 0;
      if (prodCost > 0) {
        const bw = 22, bh = 3, by = cy + 16;
        const pct = Math.min(1, c.prodStockpile / prodCost);
        ctx2d.fillStyle = '#333'; ctx2d.fillRect(cx-bw/2, by, bw, bh);
        ctx2d.fillStyle = '#ff9800'; ctx2d.fillRect(cx-bw/2, by, bw*pct, bh);
      }
    }
  }

  // Units
  for (let p=0;p<2;p++) {
    for (const u of G.players[p].units) {
      if (u.hp<=0) continue;
      const [cx,cy]=hexCenter(u.q,u.r);
      let ox=0, oy=0;
      const cityHere = G.players[p].cities.some(c=>c.q===u.q&&c.r===u.r);
      if(cityHere){ox=14;oy=-10;}
      ctx2d.beginPath(); ctx2d.arc(cx+ox,cy+oy-2,11,0,Math.PI*2);
      ctx2d.fillStyle=p===0?'#1a5276':'#922b21'; ctx2d.fill();
      const isSel = selected&&selected.type==='unit'&&selected.player===p&&selected.id===u.id;
      ctx2d.strokeStyle=isSel?'#f5c542':'rgba(255,255,255,.5)'; ctx2d.lineWidth=isSel?2.5:1.5; ctx2d.stroke();
      ctx2d.font='12px sans-serif'; ctx2d.textAlign='center';
      ctx2d.fillText(UNIT_ICONS[u.unitType]||'?',cx+ox,cy+oy+3);
      if (u.hp<100 && u.hp>0) {
        const bw=18;
        ctx2d.fillStyle='#333'; ctx2d.fillRect(cx+ox-bw/2,cy+oy+10,bw,3);
        ctx2d.fillStyle=u.hp>50?'#66bb6a':u.hp>25?'#ff9800':'#e74c3c';
        ctx2d.fillRect(cx+ox-bw/2,cy+oy+10,bw*u.hp/100,3);
      }
      ctx2d.font='7px sans-serif'; ctx2d.fillStyle='#ccc';
      ctx2d.fillText((UNIT_NAMES[u.unitType]||'Unit')+(p===1?' (B)':''),cx+ox,cy+oy+20);
    }
  }

  ctx2d.restore();
}

// ═══════════════════════════════════════════════════════════════
// MOUSE INTERACTION
// ═══════════════════════════════════════════════════════════════
let isDrag=false, dragSX,dragSY,dragCX,dragCY,dragMoved;
const mapArea = document.getElementById('map-area');

mapArea.addEventListener('mousedown', e => {
  if(e.button!==0) return;
  isDrag=true; dragMoved=false;
  dragSX=e.clientX; dragSY=e.clientY; dragCX=camX; dragCY=camY;
  mapArea.classList.add('dragging');
});
window.addEventListener('mousemove', e => {
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left-camX, my=e.clientY-rect.top-camY;
  if(isDrag){
    const dx=e.clientX-dragSX,dy=e.clientY-dragSY;
    if(Math.abs(dx)+Math.abs(dy)>4) dragMoved=true;
    camX=dragCX+dx; camY=dragCY+dy; drawMap();
    return;
  }
  const hex=pixelToHex(mx,my);
  if(hex&&(hex.q!==hoveredHex?.q||hex.r!==hoveredHex?.r)){
    hoveredHex=hex; drawMap(); showTooltip(e.clientX,e.clientY,hex);
  } else if(!hex){ hoveredHex=null; document.getElementById('tile-tip').style.display='none'; drawMap(); }
  else { const tt=document.getElementById('tile-tip'); tt.style.left=(e.clientX+14)+'px'; tt.style.top=(e.clientY+14)+'px'; }
});
window.addEventListener('mouseup', e => {
  if(isDrag&&!dragMoved){
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left-camX,my=e.clientY-rect.top-camY;
    const hex=pixelToHex(mx,my);
    if(hex) handleClick(hex);
  }
  isDrag=false; mapArea.classList.remove('dragging');
});
mapArea.addEventListener('wheel', e => {
  camX -= e.deltaX; camY -= e.deltaY; drawMap(); e.preventDefault();
}, {passive:false});

function showTooltip(mx,my,hex) {
  const tt=document.getElementById('tile-tip');
  const t=getTile(hex.q,hex.r);
  if(!t){tt.style.display='none';return;}
  let html=`<b>${TERRAIN_NAMES[t.terrain]||'?'}</b> (${hex.q},${hex.r})`;
  if(t.feature) html+=` \u2014 ${FEATURE_NAMES[t.feature]||'Feature #'+t.feature}`;
  if(t.resource) html+=`<br>Resource: ${RESOURCE_NAMES[t.resource]||'#'+t.resource}`;
  const imp = t.improvement || 0;
  if(imp) html+=`<br>Improvement: ${IMPROVEMENT_NAMES[imp]||'#'+imp}`;

  // ── Tile yields (show for all tiles except deep ocean and mountain) ──
  if(t.terrain !== 0 && t.terrain !== 12) { // not ocean/mountain
    const y = computeTileYield(t);
    const yieldParts = [];
    if(y.food) yieldParts.push(`<span style="color:var(--food)">${y.food}\u{1F33E}</span>`);
    if(y.prod) yieldParts.push(`<span style="color:#f5a623">${y.prod}\u2699\uFE0F</span>`);
    if(y.gold) yieldParts.push(`<span style="color:var(--gold)">${y.gold}\u{1F4B0}</span>`);
    if(yieldParts.length) html += `<br>Yields: ${yieldParts.join(' ')}`;

    // Show city center yield if different (settling bonus)
    const cy = computeCityCenterYield(t);
    if(cy.food !== y.food || cy.prod !== y.prod) {
      const cyParts = [];
      if(cy.food) cyParts.push(`<span style="color:var(--food)">${cy.food}\u{1F33E}</span>`);
      if(cy.prod) cyParts.push(`<span style="color:#f5a623">${cy.prod}\u2699\uFE0F</span>`);
      if(cy.gold) cyParts.push(`<span style="color:var(--gold)">${cy.gold}\u{1F4B0}</span>`);
      html += `<br>If settled: ${cyParts.join(' ')}`;
    }
  }

  if(t.ownerCity > 0) {
    const ownerLabel = t.ownerPlayer === 0 ? 'A' : 'B';
    const ownerCities = G.players[t.ownerPlayer].cities;
    const ownerCityObj = ownerCities.find(c => c.id === t.ownerCity - 1);
    const cityName = ownerCityObj ? ownerCityObj.name : 'City #' + t.ownerCity;
    html += `<br>Owner: <span style="color:var(--p${t.ownerPlayer})">${ownerLabel} \u2014 ${cityName}</span>`;
    // Show lock status if this is the selected city's territory
    if (selected && selected.type === 'city' && selected.player === t.ownerPlayer && t.ownerCity === selected.id + 1) {
      const selCity = G.players[selected.player].cities.find(c => c.id === selected.id);
      if (selCity) {
        const locked = (selCity.lockedTiles || []).some(lt => lt.q === hex.q && lt.r === hex.r);
        if (locked) {
          html += `<br><span style="color:#3498db">\u{1F512} Citizen locked to this tile</span>`;
        } else if (t.terrain !== 0 && t.terrain !== 12 && !(hex.q === selCity.q && hex.r === selCity.r)) {
          html += `<br><span style="color:#999">Click to lock citizen here</span>`;
        }
      }
    }
  }
  for(let p=0;p<2;p++){
    for(const u of G.players[p].units){
      if(u.hp>0&&u.q===hex.q&&u.r===hex.r) html+=`<br>${p===0?'A':'B'}: ${UNIT_NAMES[u.unitType]} HP:${u.hp} MP:${u.mp}`;
    }
    for(const c of G.players[p].cities){
      if(c.q===hex.q&&c.r===hex.r) html+=`<br>${p===0?'A':'B'}: ${c.name} Pop:${c.population}`;
    }
  }
  tt.innerHTML=html; tt.style.display='block';
  tt.style.left=(mx+14)+'px'; tt.style.top=(my+14)+'px';
}

// ═══════════════════════════════════════════════════════════════
// CLICK / SELECTION / ACTIONS
// ═══════════════════════════════════════════════════════════════
function handleClick(hex) {
  if(loading) return;

  // If in action mode, execute the action
  if(actionMode==='move' && selected && selected.type==='unit') {
    doAction({type:'MoveUnit', unitId:selected.id, destQ:hex.q, destR:hex.r});
    return;
  }
  if(actionMode==='attack' && selected && selected.type==='unit') {
    doAction({type:'AttackUnit', unitId:selected.id, targetQ:hex.q, targetR:hex.r});
    return;
  }
  if(actionMode==='ranged' && selected && selected.type==='unit') {
    doAction({type:'RangedAttack', unitId:selected.id, targetQ:hex.q, targetR:hex.r});
    return;
  }

  // If a city is selected and we click a territory tile, toggle citizen lock
  if (selected && selected.type === 'city' && selected.player === G.currentPlayer) {
    const city = G.players[selected.player].cities.find(c => c.id === selected.id);
    if (city) {
      const tile = getTile(hex.q, hex.r);
      // Check if this tile is in the city's territory and workable
      if (tile && tile.ownerCity === city.id + 1 && tile.ownerPlayer === selected.player
          && tile.terrain !== 0 && tile.terrain !== 12
          && !(hex.q === city.q && hex.r === city.r)) { // can't toggle city center
        const locked = city.lockedTiles || [];
        const isLocked = locked.some(lt => lt.q === hex.q && lt.r === hex.r);
        if (isLocked) {
          queuePredicted({type:'UnassignCitizen', cityId: city.id, q: hex.q, r: hex.r});
          // Update local state so UI reflects change immediately
          city.lockedTiles = locked.filter(lt => !(lt.q === hex.q && lt.r === hex.r));
          showToast('info', 'Citizen unassigned', `Tile (${hex.q},${hex.r}) set to auto-assign.`);
        } else {
          // Check if we can add more locked tiles (< population)
          if (locked.length < city.population) {
            queuePredicted({type:'AssignCitizen', cityId: city.id, q: hex.q, r: hex.r});
            // Update local state
            city.lockedTiles = [...locked, {q: hex.q, r: hex.r}];
            showToast('info', 'Citizen assigned', `Locked citizen to tile (${hex.q},${hex.r}).`);
          } else {
            showToast('error', 'All citizens assigned', 'Unassign a citizen first or grow your city.');
          }
        }
        renderSidebar(); drawMap();
        return;
      }
    }
  }

  // Try to select entity at this hex (prefer current player, then enemy)
  for (const p of [G.currentPlayer, 1 - G.currentPlayer]) {
    const unit = G.players[p].units.find(u => u.hp>0 && u.q===hex.q && u.r===hex.r);
    if (unit) {
      selected = {...unit, type:'unit', player:p};
      actionMode=null; setModeBanner(null);
      updateActionBar(); renderSidebar(); drawMap();
      return;
    }
    const city = G.players[p].cities.find(c => c.q===hex.q && c.r===hex.r);
    if (city) {
      selected = {...city, type:'city', player:p};
      actionMode=null; setModeBanner(null);
      updateActionBar(); renderSidebar(); drawMap();
      return;
    }
  }

  // Nothing at this hex
  selected=null; actionMode=null; setModeBanner(null);
  updateActionBar(); renderSidebar(); drawMap();
}

function setModeBanner(text) {
  const b = document.getElementById('mode-banner');
  if(!text){ b.style.display='none'; return; }
  b.textContent=text; b.style.display='block';
}

function cancelMode() { actionMode=null; setModeBanner(null); updateActionBar(); drawMap(); }
function startMove()  { actionMode='move';   setModeBanner('Click destination hex to move'); updateActionBar(); drawMap(); }
function startAttack(){ actionMode='attack'; setModeBanner('Click enemy unit to attack (melee)'); updateActionBar(); drawMap(); }
function startRanged(){ actionMode='ranged'; setModeBanner('Click enemy unit for ranged attack'); updateActionBar(); drawMap(); }

// ═══════════════════════════════════════════════════════════════
// ACTION QUEUE — predicted actions are batched with next unpredicted
// ═══════════════════════════════════════════════════════════════
const PREDICTED_ACTIONS = new Set([
  'SetResearch', 'SetProduction', 'FortifyUnit', 'SkipUnit',
  'DeclareWar', 'BuildImprovement', 'RemoveImprovement',
  'PurchaseWithGold', 'UpgradeUnit'
]);
let pendingActions = [];

function updateQueueBadge() {
  const badge = document.getElementById('queue-badge');
  const lbl = document.getElementById('queue-lbl');
  if (pendingActions.length === 0) { badge.style.display='none'; return; }
  badge.style.display='';
  lbl.textContent = pendingActions.length + ' queued';
}

// Queue a predicted action — no transaction sent yet
function queuePredicted(action) {
  pendingActions.push(action);
  updateQueueBadge();
}

// Flush queued predicted actions + the triggering unpredicted action
async function flushWithAction(unpredictedAction) {
  const batch = [...pendingActions, unpredictedAction];
  pendingActions = [];
  updateQueueBadge();
  const hasEndTurn = batch.some(a => a.type === 'EndTurn');
  await submitBatch(batch, hasEndTurn);
}

// Send a batch to the server
async function submitBatch(actions, isEndTurn) {
  if(loading) return;
  loading=true;
  document.getElementById('end-btn').disabled=true;
  try {
    // Use /api/turn for EndTurn (triggers end-of-turn processing),
    // /api/actions for mid-turn batches
    const endpoint = isEndTurn ? '/api/turn' : '/api/actions';
    const res = await fetch(endpoint, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({player: G.currentPlayer, actions})
    });
    const data = await res.json();
    if(!res.ok) {
      const summary = batchSummary(actions);
      showToast('error', 'Transaction failed', `<b>Reason:</b> ${data.error}<br><b>Actions:</b> ${summary}`, 10000);
      loading=false; document.getElementById('end-btn').disabled=false; return;
    }
    selected=null; actionMode=null; setModeBanner(null);
    await refreshState();
    if (isEndTurn) centerCamera();
  } catch(e) {
    const summary = batchSummary(actions);
    showToast('error', 'Network error', `<b>Details:</b> ${e.message}<br><b>Actions:</b> ${summary}`, 10000);
  }
  loading=false;
  document.getElementById('end-btn').disabled=false;
}

// --- Predicted actions (queued locally, no transaction) ---

function fortifyUnit() {
  if(!selected) return;
  queuePredicted({type:'FortifyUnit', unitId:selected.id});
}

function skipUnit() {
  if(!selected) return;
  queuePredicted({type:'SkipUnit', unitId:selected.id});
}

function declareWar() {
  if (!confirm('Declare war on the other player?')) return;
  const target = G.currentPlayer === 0 ? 1 : 0;
  queuePredicted({type:'DeclareWar', target});
}

// --- Unpredicted actions (flush queue + send transaction) ---

async function doAction(action) {
  actionMode=null; setModeBanner(null);
  await flushWithAction(action);
}

async function foundCity() {
  if(!selected||selected.unitType!==0) return;
  const name = prompt('City name:', 'City');
  if(!name) return;
  await flushWithAction({type:'FoundCity', settlerId:selected.id, name});
}

async function endTurn() {
  await flushWithAction({type:'EndTurn'});
}

// Legacy alias — kept for backward compatibility
async function submitActions(actions) {
  await submitBatch(actions, actions.some(a => a.type === 'EndTurn'));
}

// ═══════════════════════════════════════════════════════════════
// RIGHT PANEL (Tech / Production)
// ═══════════════════════════════════════════════════════════════
function openPanel(type) {
  const panel = document.getElementById('rpanel');
  const title = document.getElementById('rp-title');
  const body  = document.getElementById('rp-body');
  panel.classList.add('open');

  // Helper: check if a tech is researched from completedTechs bitmask
  const cp = G.players[G.currentPlayer];
  const techBits = BigInt(cp.completedTechs || '0');
  function hasTech(techId) {
    if (!techId || techId === 0) return true;
    return (techBits & (1n << BigInt(techId - 1))) !== 0n;
  }

  // Tech requirements per unit (prod item ID -> tech ID, 0 = none)
  const UNIT_REQ_TECH = {1:0,2:0,3:0,4:0,5:0,6:4}; // Archer needs Archery(4)
  // Tech requirements per building (building bit -> tech ID, 0 = none)
  const BLDG_REQ_TECH = {0:0,1:2,2:8,3:7,4:11,5:9,6:10};

  if(type==='tech') {
    panel.classList.add('wide');
    title.textContent='Research Tree';

    // Tech tree data: prereqs mirror Cairo tech.cairo
    const PREREQS = {1:[],2:[],3:[],4:[3],5:[],6:[2],7:[2],8:[1],9:[1],10:[1],
      11:[7],12:[8,10],13:[3],14:[9],15:[5],16:[11,12],17:[12],18:[4,17]};
    const COST = {1:25,2:25,3:25,4:35,5:40,6:40,7:45,8:50,9:50,10:50,
      11:60,12:80,13:80,14:80,15:80,16:100,17:100,18:100};

    // ── Horizontal layout: each tech has [column, y-pixel] ──
    // Columns flow left→right. Vertical positions are hand-tuned so
    // connector lines never cross each other.
    const NW = 94, NH = 40, COL_GAP = 124;
    const POS = {
      // Col 0 — Ancient (no prereqs)
      5:  [0,   0],   // Sailing
      2:  [0, 100],   // Pottery
      3:  [0, 210],   // Animal Husbandry
      1:  [0, 320],   // Mining
      // Col 1
      15: [1,   0],   // Celestial Nav ← Sailing
      6:  [1,  65],   // Irrigation ← Pottery
      7:  [1, 115],   // Writing ← Pottery
      4:  [1, 200],   // Archery ← AH
      13: [1, 250],   // Horseback ← AH
      8:  [1, 290],   // Masonry ← Mining
      10: [1, 335],   // The Wheel ← Mining
      9:  [1, 380],   // Bronze Working ← Mining
      // Col 2 — Classical
      11: [2, 115],   // Currency ← Writing
      12: [2, 312],   // Construction ← Masonry + Wheel
      14: [2, 380],   // Iron Working ← Bronze
      // Col 3
      16: [3, 210],   // Mathematics ← Currency + Construction
      17: [3, 312],   // Engineering ← Construction
      // Col 4 — Medieval
      18: [4, 255],   // Machinery ← Archery + Engineering
    };

    function canResearch(id) {
      if (hasTech(id)) return false;
      for (const p of PREREQS[id]) { if (!hasTech(p)) return false; }
      return true;
    }

    const PAD = 10;
    const totalW = PAD + 5 * COL_GAP - (COL_GAP - NW) + PAD;
    const totalH = PAD + 380 + NH + PAD;

    let html = `<div class="tech-tree" id="tech-tree-container" style="width:${totalW}px;height:${totalH}px">`;

    // Era labels (vertical text beside each era's first column)
    const eras = [{col:0,label:'Ancient'},{col:2,label:'Classical'},{col:4,label:'Medieval'}];
    for (const e of eras) {
      const ex = PAD + e.col * COL_GAP - 9;
      html += `<div class="tech-era-label" style="left:${ex}px;top:${PAD}px">${e.label}</div>`;
    }

    // Render nodes
    for (let id = 1; id <= 18; id++) {
      const [col, py] = POS[id];
      const x = PAD + col * COL_GAP;
      const y = PAD + py;
      const done = hasTech(id);
      const avail = canResearch(id);
      const cls = done ? 'done' : avail ? 'available' : 'locked';
      const onclick = avail ? `onclick="setResearch(${id})"` : '';
      html += `<div class="tech-node ${cls}" data-tech-id="${id}" ${onclick} style="left:${x}px;top:${y}px;width:${NW}px;height:${NH}px">`;
      html += `<span class="tn-name">${TECH_NAMES[id]}</span>`;
      html += `<span class="tn-cost">\u{1F52C} ${COST[id]}</span>`;
      html += '</div>';
    }
    html += '</div>';
    body.innerHTML = html;

    // Draw SVG connector lines (right-edge → left-edge, horizontal beziers)
    requestAnimationFrame(() => {
      const container = document.getElementById('tech-tree-container');
      if (!container) return;
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.classList.add('tree-lines');
      svg.setAttribute('width', totalW);
      svg.setAttribute('height', totalH);

      for (let id = 1; id <= 18; id++) {
        const [tc, ty] = POS[id];
        for (const pid of PREREQS[id]) {
          const [fc, fy] = POS[pid];
          // From right-center of parent to left-center of child
          const x1 = PAD + fc * COL_GAP + NW;
          const y1 = PAD + fy + NH / 2;
          const x2 = PAD + tc * COL_GAP;
          const y2 = PAD + ty + NH / 2;
          const mx = (x1 + x2) / 2;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          path.setAttribute('d', `M${x1},${y1} C${mx},${y1} ${mx},${y2} ${x2},${y2}`);
          path.classList.add('tree-line');
          if (hasTech(pid) && hasTech(id)) path.classList.add('done');
          svg.appendChild(path);
        }
      }
      container.insertBefore(svg, container.firstChild);
    });

  } else if(type==='prod') {
    panel.classList.remove('wide');
    title.textContent='Set Production';
    // IDs match contract: PROD_SETTLER=1, PROD_BUILDER=2, PROD_SCOUT=3,
    // PROD_WARRIOR=4, PROD_SLINGER=5, PROD_ARCHER=6, buildings at 64+
    const items = [
      {id:1,name:'Settler',cost:80},{id:2,name:'Builder',cost:50},{id:3,name:'Scout',cost:30},
      {id:4,name:'Warrior',cost:40},{id:5,name:'Slinger',cost:35},{id:6,name:'Archer',cost:60},
      {id:64,name:'Monument',cost:60},{id:65,name:'Granary',cost:65},
      {id:66,name:'Walls',cost:80},{id:67,name:'Library',cost:90},{id:68,name:'Market',cost:100},
      {id:69,name:'Barracks',cost:90},{id:70,name:'Water Mill',cost:80},
    ];
    // Get selected city's buildings to grey out already-built buildings
    let cityBuildings = 0;
    if (selected && selected.type === 'city' && selected.player === G.currentPlayer) {
      cityBuildings = selected.buildings || 0;
    } else if (cp.cities.length > 0) {
      cityBuildings = cp.cities[0].buildings || 0;
    }
    let html='';
    for(const it of items){
      const cat = it.id >= 64 ? 'Building' : 'Unit';
      let locked = false;
      let lockReason = '';
      if (it.id >= 1 && it.id <= 63) {
        // Unit: check required tech
        const reqTech = UNIT_REQ_TECH[it.id] || 0;
        if (reqTech && !hasTech(reqTech)) {
          locked = true;
          lockReason = `Requires ${TECH_NAMES[reqTech]}`;
        }
      } else if (it.id >= 64) {
        // Building: check required tech + already built
        const bbit = it.id - 64;
        const reqTech = BLDG_REQ_TECH[bbit] || 0;
        if (reqTech && !hasTech(reqTech)) {
          locked = true;
          lockReason = `Requires ${TECH_NAMES[reqTech]}`;
        } else if (cityBuildings & (1 << bbit)) {
          locked = true;
          lockReason = 'Already built';
        }
      }
      if (locked) {
        html+=`<div class="rp-item" style="opacity:.4;cursor:default"><span>\u{1F512} ${it.name}</span><span class="meta" style="color:#f66">${lockReason}</span></div>`;
      } else {
        html+=`<div class="rp-item" onclick="setProduction(${it.id})"><span>\u{1F3D7} ${it.name}</span><span class="meta">${cat} \u2022 \u2692${it.cost}</span></div>`;
      }
    }
    body.innerHTML=html;
  }
  setTimeout(resizeCanvas, 50);
}
function closePanel() {
  const p = document.getElementById('rpanel');
  p.classList.remove('open');
  p.classList.remove('wide');
  setTimeout(resizeCanvas, 50);
}

// setResearch / setProduction are now predicted (queued)
function setResearch(techId) {
  closePanel();
  queuePredicted({type:'SetResearch', techId});
}

function setProduction(itemId) {
  let cityId;
  if(!selected || selected.type!=='city') {
    const cp = G.currentPlayer;
    const city = G.players[cp].cities[0];
    if(!city){ showToast('error', 'No city', 'You need a city to set production.'); closePanel(); return; }
    cityId = city.id;
  } else {
    cityId = selected.id;
  }
  closePanel();
  queuePredicted({type:'SetProduction', cityId, itemId});
}

// ═══════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════
setTimeout(resizeCanvas, 50);
</script>
</body>
</html>
